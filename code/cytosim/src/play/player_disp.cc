// Cytosim was created by Francois Nedelec. Copyright 2007-2017 EMBL.
#include "sim.h"
#include "modulo.h"
#include "display1.h"
#include "display2.h"
#include "display3.h"
#include "saveimage.h"
#include "filepath.h"
#include "glut.h"


extern bool functionKey[];
extern Modulo const* modulo;

using  glApp::GP;

//------------------------------------------------------------------------------
void Player::initStyle(const int style)
{
    //std::clog << "Player::initStyle(" << style << ")" << std::endl;

    if ( mDisplay )
    {
        //restore the previous OpenGL state
        glPopAttrib();
        delete(mDisplay);
        mDisplay = 0;
    }
    
    //save the current OpenGL state
    glPushAttrib(GL_ALL_ATTRIB_BITS);
    
    DP.style = style;
    switch ( style )
    {
        default:
        case 1: mDisplay = new Display1(&DP);  break;
        case 2: mDisplay = new Display2(&DP);  break;
        case 3: mDisplay = new Display3(&DP);  break;
    }
    
    // initialize Views associated with opened GLUT windows:
    for ( unsigned n = 1; n < glApp::views.size(); ++n )
    {
        View & view = glApp::views[n];
        if ( view.window() > 0 )
        {
            //std::clog << "initializing GLUT window " << n << std::endl;
            glutSetWindow(view.window());
            view.initGL();
            glViewport(0, 0, view.width(), view.height());
        }
    }
}

//------------------------------------------------------------------------------
#pragma mark -

/**
 Build a message containing the label and the time.
 For an interactive window, it also adds 'live' or the frame index,
 and the force generated by the mouse.
 */
std::string Player::buildMessageB(Simul const& simul)
{
    std::ostringstream oss;
    oss.precision(3);

    oss << std::setw(8) << std::fixed << simul.time() << "s";
    
    //display the force exerted by the mouse-controled Single:
    Single * sh = simThread.handle();
    if ( sh && sh->attached() )
        oss << "\nHandle: " << sh->force().norm() << "pN";

    if ( PP.live )
    {
        oss << "\nLive";
        //display ratio number-of-time-step / frame
        if ( PP.period > 1 )
            oss << " " << PP.period;
    }
    else
    {
        if ( simThread.currFrame() >= 0 )
            oss << "\nFrame " << simThread.currFrame();
    }

    return oss.str();
}


/**
 This information is displayed in the top corner of the window.
 Calling simul.report() maked sure that the message is identical to what
 would be printed by the command 'report'.
 */
std::string Player::buildMessageT(Simul const& simul)
{
    if ( PP.report.empty() )
        return "";
    
    Glossary opt;
    std::stringstream ss;
    simul.report0(ss, PP.report, opt);
    std::string str = ss.str();
    if ( str.size() > 1  &&  str.at(0) == '\n' )
        return str.substr(1);
    return str;
}

/**
 This text is normally displayed in the center of the window
 */
std::string Player::buildMessage(int type)
{
    std::ostringstream oss;
    switch ( type )
    {
        case 0: return "";
        case 1: return "Please, visit www.cytosim.org";
        case 2: Player::helpKeys(oss); return oss.str();
        case 3: glApp::help(oss);  return oss.str();
        case 4: writePlayParameters(oss, true); return oss.str();
        case 5: writeDisplayParameters(oss, true); return oss.str();
    }
    return "";
}

//------------------------------------------------------------------------------
#pragma mark Display
#include "vecprint.h"

void Player::autoTrack(FiberSet const& fibers, View& view)
{
    Vector G(0, 0, 0);
    Vector D(0, 0, 0);
    real vec[9] = { 1, 0, 0, 0, 1, 0, 0, 0, 1 };
    
    if ( view.track_fibers & 1 )
    {
        Vector M, P;
        FiberSet::infoPosition(fibers.collect(), M, G, P);
        view.move_shift(Vector3(G));
        //std::clog << "auto center: " << G << std::endl;
    }
    
    if ( view.track_fibers & 2 )
    {
        // align with mean nematic direction
        FiberSet::infoNematic(fibers.collect(), vec);
        view.align_with(Vector3(vec));
        //view.rotation.setFromMatrix3(vec);
        //view.rotation.conjugate();
        //std::clog << "auto rotate: " << Vector3(vec) << std::endl;
    }

    if ( view.track_fibers & 4 )
    {
        real sum = 0;
        real avg[3] = { 0 };
        real mom[9] = { 0 };
        FiberSet::infoComponents(fibers.collect(), sum, avg, mom, vec);
        // get rotation from matrix:
        view.rotation.setFromMatrix3(vec);
        // inverse rotation:
        view.rotation.conjugate();
        //std::clog << "auto quat: " << view.rotation << std::endl;
    }
}


/**
 Adjust to see the biggest Space in simul
 */
int Player::autoScale(SpaceSet const& spaces, View& view)
{
    real rad = 0;
    for ( Space const* spc = spaces.first(); spc; spc=spc->next() )
    {
        real r = 2*spc->max_extension();
        if ( r > rad ) rad = r;
    }
    if ( rad > 0 )
    {
        //std::cerr << "auto_scale " << rad << std::endl;
        view.setScale(rad);
        view.set();
        //view.zoom_in(0.97);
        return 1;
    }
    return 0;
}


void Player::prepareDisplay(View& view, Simul const& simul, real mag)
{    
    gle::gleReportErrors(stderr, "before prepareDisplay");
    
    //----------------- automatic adjustment of viewing area:

    if ( view.auto_scale > 0 )
        view.auto_scale -= autoScale(simul.spaces, view);
    
    //----------------- auto-track:
    
    if ( view.track_fibers )
        autoTrack(simul.fibers, view);
    
    //----------------- texts:
    
    view.setMessage(view.label + " " + buildMessageB(simul));
    view.setMessageT(buildMessageT(simul));
    
    //gle::gleReportErrors(stderr, "before setPixelFactor");
    
    //----------------- set pixel size and unit-size:
    /*
     if DP.point_value is set, line-width and point-size were specified in 'real' units,
     and otherwise, they were specified in pixels.
     */
    if ( DP.point_value > 0 )
        mDisplay->setPixelFactors(view.pixelSize()/mag, mag*DP.point_value/view.pixelSize());
    else
        mDisplay->setPixelFactors(view.pixelSize()/mag, mag);

    //----------------- prepare objects:
    gle::gleReportErrors(stderr, "after setPixelFactor");

    try {
        mDisplay->prepareForDisplay(simul, dproperties);
    } catch(Exception & e) {
        std::cerr<<"Error in prepareDisplay: " << e.what() << std::endl;
    }
}

//------------------------------------------------------------------------------
void Player::displayCytosim(Simul const& simul)
{
    //std::clog << "displayCytosim win=" << glutGetWindow() << std::endl;
    
    //----------------- clear pixels:
    
    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    //----------------- draw:

    try {

        if ( modulo && DP.tile )
            mDisplay->displayTiled(simul, DP.tile);
        else
            mDisplay->display(simul);

        if ( functionKey[1] )
        {
            /**
             This will work only if meca_inter.cc is compiled with
             DISPLAY_INTERACTIONS enabled
            */
            glPushAttrib(GL_LIGHTING_BIT);
            glDisable(GL_LIGHTING);
            Meca tmp;
            tmp.displayInteractions = true;
            const_cast<Simul&>(simul).prepare();
            simul.setInteractions(tmp);
            glPopAttrib();
            gle::gleReportErrors(stderr, "with DISPLAY_INTERACTIONS");
        }
        
    }  catch(Exception & e) {
        std::cerr<<"Error in display: " << e.what() << std::endl;
    }
}


/**
 display is done only if data can be accessed by this thread,
 otherwise display is postponed with a call to postRedisplay()
 */
void Player::displayLive()
{
    if ( 0 == simThread.trylock() )
    {
        //std::clog << pthread_self() << " displayLive win " << glutGetWindow() << std::endl;
        // read the "display" parameters if they have changed
        if ( simul.prop->display_fresh )
        {
            try
            {
                Glossary glos(simul.prop->display);
                GP.read(glos);
                DP.read(glos);
                View & view = glApp::currentView();
                //std::clog << simul.prop->display << std::endl;
                const int W = view.width();
                const int H = view.height();
                view.read(glos);
#if ( 1 )
                // window size cannot be changed:
                view.window_size[0] = W;
                view.window_size[1] = H;
#else
                if ( view.width() != W || view.height() != H )
                    glutReshapeWindow(view.width(), view.height());
#endif
                view.set();
            }
            catch( Exception & e )
            {
                std::cerr << "Error: " << e.what() << std::endl;
            }
            simul.prop->display_fresh = false;
        }
        
        // display simulation world:
        prepareDisplay(glApp::currentView(), simul);
        displayCytosim(simul);
        simThread.unlock();
    }
    else
    {
        //std::clog << pthread_self() << " failed trylock\n";
        glutPostRedisplay();
    }
}


/**
 This is a bare-bone version used for off-screen rendering.
 */
void Player::displayScene(int mag)
{
    //std::clog << "displayScene win=" << glutGetWindow() << std::endl;
    View & view = glApp::currentView();
    prepareDisplay(view, simul, mag);
    view.openDisplay();
    displayCytosim(simul);
    view.closeDisplay();
    glFinish();
}


//------------------------------------------------------------------------------
#pragma mark Export Image

/**
 Export image from the current OpenGL buffer (displayed image),
 in the format specified by 'PlayProp::image_format',
 in the folder specified in `PlayProp::image_dir`.
 The name of the file is formed by concatenating 'root' and number 'indx'.
 */
int Player::saveImage(const char* root, unsigned indx)
{
    char name[1024];
    char const* format = PP.image_format.c_str();
    snprintf(name, sizeof(name), "%s%04i.%s", root, indx, format);
    std::string cwd;
    if ( PP.image_dir.length() )
    {
        cwd = FilePath::get_dir();
        FilePath::change_dir(PP.image_dir);
    }
    int err = SaveImage::saveImage(name, format, PP.downsample);
    if ( cwd.length() )
        FilePath::change_dir(cwd);
    return err;
}


//------------------------------------------------------------------------------

void displayMagnified(int mag, void * arg)
{
    Player::displayCytosim(*static_cast<Simul*>(arg));
    gleReportErrors(stderr, "in displayMagnified");
}


/**
 save an image where the resolution is magnified by a factor `mag`.
 This requires access to the simulation world.
 */
int Player::saveMagnifiedImage(const int mag, const char* name, const char* format, const int downsample)
{
    if ( !SaveImage::supported(format) )
    {
        std::cerr << "Error unsupported image format `" << format << "'"<< std::endl;
        return -1;
    }
    
    View & view = glApp::currentView();
    const int W = view.width(), H = view.height();
    
    simThread.lock();
    
    //std::clog << "saveMagnifiedImage " << W << "x" << H << " mag=" << mag << std::endl;

    Player::prepareDisplay(view, simul, mag);

    view.openDisplay();
    
    int err = SaveImage::saveMagnifiedImage(mag, name, format, W, H, displayMagnified, &simul, downsample);
    
    if ( err )
    {
        std::clog << " ... trying alternative method:" << std::endl;
        err = SaveImage::saveCompositeImage(mag, name, format, W, H, view.pixelSize(), displayMagnified, &simul);
    }
    
    view.closeDisplay();
    simThread.unlock();
    return err;
}


/**
 save an image where the resolution is magnified by a factor `mag`.
 This requires access to the simulation world.
 */
int Player::saveMagnifiedImage(const int mag, const char* root, unsigned indx, const int downsample)
{
    char name[1024];
    char const* format = PP.image_format.c_str();
    snprintf(name, sizeof(name), "%s%04i.%s", root, indx, format);
    std::string cwd;
    if ( PP.image_dir.length() )
    {
        cwd = FilePath::get_dir();
        FilePath::change_dir(PP.image_dir);
    }
    int err = saveMagnifiedImage(mag, name, format, downsample);
    if ( cwd.length() )
        FilePath::change_dir(cwd);
    glApp::postRedisplay();
    return err;
}

